# 10. 指针 (内存地址)

通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。

要理解指针就要先理解计算机的内存。**计算机内存会被划分为按顺序编号的内存单元**。每个变量都是存储在内存单元中的，称之为地址。内存以字节（Byte）为单位，即计算机最小访问存储单位为字节。

**每一个变量都有一个内存位置，每一个内存位置都定义了可使用 `&` 运算符访问的地址，它表示在内存中的一个地址**。

下例将输出定义的变量地址：

```c
# include <stdio.h>

int main(){
	int var_runoob = 10;
	int *p;
	
	p = &var_x;
	
	printf("var_runoob 变量的地址为：%p\n", p);
	// var_runoob 变量的地址为：000000000062FE14
    
	return 0;
}
```

![](./imgs/c-pointer.png)

通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。

## 10.1 什么是指针？

<font color=red>**指针就是内存地址，指针变量是用来存放内存地址的变量**</font>。像其他变量或常量一样，在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式：

```c
type *var-name;
```

在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 ***** 与乘法中使用的星号是相同的。**星号用来指定一个变量是指针**。以下是有效的指针声明：

```c
int 	*ip;  /* 一个整型的指针 */
double  *dp;  /* 一个 double 型的指针 */
float 	*fp;  /* 一个浮点型的指针 */
char 	*ch;  /* 一个字符型的指针 */
```

**所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数**。不同数据类型的指针之间唯一的不同是，**指针所指向的变量或常量的数据类型不同**。

## 10.2 如何使用指针？

<font color=blue>**使用指针的步骤**</font>：

- 定义一个指针变量；

- 把变量地址赋值给指针；

- 访问指针变量中可用地址的值。

这些是**通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值**。下面的实例涉及到了这些操作：

```c
int main(){
	/* 实际变量的声明
	   此时 VAR 变量存储了某个地址，该地址对应某个内存单元，这个单元中存储了数据10 
	*/ 
	int var = 10;
	
	/* 指针变量的声明
	   定义一个指针，即一个内存单元的地址变量 
	*/
	int *ip;
	
	/* 在指针变量中存储 var 的地址
	   将地址的值 赋值给指针变量 var 
	*/ 
	ip = &var;
	
	/* 在指针变量中存储的地址
	   &var 输出了 var 变量所存储的数据的内存单元的地址 
	*/
	printf("Address of var variable: %p\n", &var);
	
	/* ip 表示赋值变量的地址的值 */ 
	printf("Address stored in ip variable: %p\n", ip);
	
	/* 使用指针访问值 
	   *ip 表示定义内存单元后，内存单元中所存储的数据的值，本例中即为 10  
	*/ 
	printf("Value of *ip variable: %d\n", *ip);
	
	return 0;
} 
```

输出：

```c
Address of var variable: 000000000062FE14
Address stored in ip variable: 000000000062FE14
Value of *ip variable: 10
```

## 10.3 C中的NULL指针

**在变量声明时，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯**。赋为 NULL 值的指针被称为**空指针**。

**NULL 指针是一个定义在标准库中的值为零的常量**。

```c
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
```

输出：

```c
ptr 的地址是 0x0
```

**在大多数操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的**。然而，**内存地址 0 表明该指针不指向一个可访问的内存位置**。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，可以使用 if 语句：

```c
if (ptr){}

if (!ptr){}
```

## 10.4 C指针的算术运算

<font color=red>**C指针是一个数值表示的地址**</font>。可以对指针进行四种算术运算：`++、--、+、-`。

假设 **ptr** 是一个指向地址 1000 的整型指针，是一个 32 位的整数，对该指针执行下列的算术运算：

```c
ptr++
```

在执行完上述的运算之后，**ptr** 将指向位置 1004，因为 **ptr 每增加一次，它都将指向下一个整数位置**，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。

如果 **ptr** 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

总结如下：

- 指针的每一次递增，都会指向下一个元素的存储单元；
- 指针的每一次递减，都会指向上一个元素的存储单元；
- 指针在递增和递减时，<font color=red>**跳跃的字节数取决于指针所指向变量数据类型的长度**</font>，比如int为4个字节。

### 1）指针的增减

**一般在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看做一个指针常量**。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：

```c
# include <stdio.h>

const int MAX = 3;

int main() {
	int var[] = {10, 100, 200};
	int i, j, *ptr1, *ptr2;
	
	// 指针中的数组地址
	ptr1 = var;
    // 递增一个指针
	for(i=0; i<MAX; i++){
		printf("存储地址： var[%d] = %p\n", i, ptr1);
		printf("存储值  ： var[%d] = %d\n", i, *ptr1);
		
		// 指向下一个位置
		ptr1++; 
	}
	
    // 递减一个指针
    // ptr2 = var; 做修改
	// 指针中最后一个元素的地址
	ptr2 = &var[MAX-1];
    
    for(j=MAX; j>0; j--){
        printf("存储地址：var[%d] = %p\n", j-1, ptr2);
        printf("存储值  ：var[%d] = %d\n", j-1, *ptr2);
        
        // 指向下一个位置
        ptr2--;
    }
	
	return 0;
} 
```

输出：

```c
存储地址： var[0] = 000000000062FDF0
存储值  ： var[0] = 10
存储地址： var[1] = 000000000062FDF4
存储值  ： var[1] = 100
存储地址： var[2] = 000000000062FDF8
存储值  ： var[2] = 200
存储地址：var[2] = 000000000062FDF8
存储值  ：var[2] = 200
存储地址：var[1] = 000000000062FDF4
存储值  ：var[1] = 100
存储地址：var[0] = 000000000062FDF0
存储值  ：var[0] = 10
```

### 2）指针的比较

指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 的大小进行比较。

```c
# include <stdio.h>

const int MAX = 3;

int main() {
	int var[] = {10, 100, 200};
	int i, j, *ptr;
	
	ptr = var;
	i = 0;
	while(ptr <= &var[MAX - 1]) {
		printf("存储地址： var[%d] = %p\n", i, ptr);
		printf("存储值  ： var[%d] = %d\n", i, *ptr);
		
		// 指向下一个位置 
		ptr ++;
		i ++;
	} 
	return 0;
}
```

## 10.5 指针数组与数组指针

先看一个实例，它用到了一个由 3 个整数组成的数组：

```c
# include <stdio.h>

const int MAX = 3;

int main() {
	int var[] = {10, 100, 200};
	int i;
	
	for (i=0; i<MAX; i++){
		printf("Value of var[%d] = %d\n", i, var[i]);
	} 
	
	return 0;
}
```

有时需要使用数组存储指向 int 或 char 或其他数据类型的指针。

```c
int *ptr[MAX];
```

**此处，把 ptr 声明为一个数组，由 MAX 个整数指针组成**。因此，**ptr 中的每个元素，都是一个指向 int 值的指针**。下面的实例用到了三个整数，它们将存储在一个**指针数组**中：

```c
# include <stdio.h>

const int MAX = 5;

int main() {
	int var[] = {1,2,3,4,5};
	
	// 1.声明 【指针数组】
	int i, *ptr[MAX];
	
	// 2.为数组ptr中的元素赋值 
	for(i=0; i<MAX; i++){
		// 赋值为整数的地址 
		ptr[i] = &var[i]; 
	} 
	
	// 3.遍历打印 数组中的指针对应的值 
	for(i=0; i<MAX; i++){
		printf("Value of var[%d] = %d\n", i, *ptr[i]);
	}
	return 0;
}
```

**数组指针**实现方式：

```c
# include <stdio.h>

const int MAX = 5;

int main() {
	int var[MAX] = {1,2,3,4,5};
	
	// 1.声明 【数组指针】
	int i, (*ptr)[MAX];
	
	// 2.将数组names的首地址赋值给指针ptr 
	ptr = &var;
	
	// 3. 遍历打印 
	for(i=0; i<MAX; i++){
		printf("Value of var[%d] = %d\n", i, var[i]);
	}
	return 0;
}
```

也可以用一个指向字符的**指针数组**来存储一个字符串列表：

```c
# include <stdio.h>

const int MAX = 4;

int main(){
    // 定义指针数组
	const char *names[] = {
		"Zara Ali",
        "Hina Ali",
        "Nuha Ali",
        "Sara Ali",
	};
	
	int i=0;
	
	for(i=0; i<MAX; i++){
		printf("Value of names[%d] = %s\n", i, names[i]);
	}
	return 0;
} 
```

辅助理解：

- 指针数组：一个邮箱里很多封地址不同的邮件。

- 数组指针：一封地址明确的邮件里很多张信纸。

**指针数组**：指针的数组，首先这个变量是一个数组，长度由数组本身决定。其次，指针修饰这个数组，即**这个数组的所有元素都是指针类型**，存放的都是地址。在 32 位系统中，指针占四个字节。例如：

```c
const int MAX = 4;

int *a[MAX];
```

`[]` 的优先级高于 `*`，所以这是一个数组，而 `*` 修饰数组，所以是**指针数组**。数组的元素是 `int` 型的指针。

**数组指针**：数组的指针，首先这个变量是一个指针，**长度固定(32 位系统下，指针占 4 个字节)**。其次，数组修饰这个指针，即**这个指针存放着一个数组的首地址**，或者说这个指针指向一个数组的首地址，但指向的数组占多少个字节不确定。

```c
int (*a)[MAX];
```

首先，括号的优先级最高，所以 `*a` 是指针；`[]` 修饰 `*a`，所以是 **数组指针**，`int (*a)[MAX]` 表示一个指向 `MAX` 个元素的一维数组指针，每个元素都是 `int` 类型。

```c
const int MAX = 5;

int a[MAX] = {2021,4,28,10,30};  // 定义一个包含MAX个元素的一维数组 a
int (*ptr)[MAX];  // 定义包数组指针，即ptr指向的数组包含MAX元素

ptr = &a;  // 将数组a的首地址赋值给ptr，而*ptr表示数组a本身 (数组的值)
 ptr[0];  // 数组中首个元素的地址
*ptr[0];  // 数组中首个元素的值，即2021
**ptr;    // 数组中首个元素的值，即2021

*ptr[1]   // 指向数组下一行的首个元素的值；但此例中a为一维数组，只有一行，所以指向的地址中的值不确定。
```

<font color=red>注意：**数组指针加 1**，步长为所指向数组的列数，即**指向下一行的首地址**，只**在二维及以上维度的数组中有意义，一维数组只有一行，无意义**。</font>

---

## 10.6 指向指针的指针

**指向指针的指针**是一种**多级间接寻址**的形式，或者说是一个**指针链**。通常，一个指针包含一个变量的地址。指向指针的指针：**第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置**。

![C 中指向指针的指针](./imgs/pointer_to_pointer.jpg)

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号运算符：

```c
int **var;
```

图解：

![img](./imgs/c-pointerxxxxx.png)

实例：

```c
# include <stdio.h>

int main(){
	int var = 408;
	int *ptr1;
	int **ptr2;
	
	// 获取 var 的地址
	ptr1 = &var;
	 
	ptr2 = &ptr1;
	
	printf("var = %d\n", var);
	printf("(  ptr1) address of ptr1 = %p\n",   ptr1);
	printf("( *ptr1) value   of ptr1 = %d\n",  *ptr1);
	
	printf("(  ptr2) address of ptr2 = %p\n",   ptr2);
	printf("(**ptr2) value   of ptr2 = %d\n", **ptr2);
	
	
	return 0;
}
```

输出：

```c
var = 408
(  ptr1) address of ptr1 = 000000000062FE14
( *ptr1) value   of ptr1 = 408
(  ptr2) address of ptr2 = 000000000062FE08
(**ptr2) value   of ptr2 = 408
```

---

## 10.7 传递指针给函数

只需要声明函数参数为指针类型即可。

下面的实例，传递一个无符号的 long 型指针给函数，并在函数内改变这个值：

```c
# include <stdio.h>
# include <time.h>

void get_seconds(unsigned long *sec); 

int main(){
	unsigned long sec;
	
	get_seconds( &sec );
	
	printf("number of seconds: %ld\n", sec);
} 


void get_seconds(unsigned long *param){
	
	// 获取当前的秒数
	*param = time( NULL );
	
	return; 
}
```

上例直接直接修改了sec 的值。<font color=blue>**通过传递指针给函数，可以直接修改原参数（实参），而不是引用实参到形参**</font>。

<font color=red>**能接受指针作为参数的函数，也能接受数组作为参数**</font>：

```c
# include <stdio.h>

double get_average(int *arr, int size);

int main(){
	int balance[5] = {2021, 4, 28, 11, 35};
	double avg;
	
	avg = get_average(balance, 5);
	
	printf("Average value is: %f\n", avg);
	
	return 0;
}

double get_average(int *arr, int size){
	int i, sum = 0;
	double avg;
	
	for(i=0; i<size; ++i){
		sum += arr[i];
	}
	avg = (double) sum/size;
	
	return avg;
}
```

## 10.8 从函数返回指针

C 语言支持从函数返回数组，类似地，C 允许从函数返回指针。为了做到这点，必须声明一个返回指针的函数：

```c
int *myFunc(){
    
}
```

<font color=green>另外，C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 **`static`** 变量</font>。<font color=skyblue>因为**局部变量存储在内存的栈区内**，函数调用结束后，局部变量所占的内存地址被释放，因此函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。**static 变量的值存放在内存中的静态数据区**，不会随着函数执行的结束而被清除，故能返回其地址</font>。

下面的函数会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们：

```c
# include <stdio.h>
# include <time.h>
# include <stdlib.h>

// 注意星号运算符 
int * get_random(){
	static int r[10];
	int i;
	
	// 设置种子
	srand( (unsigned) time ( NULL) );
	for(i=0; i<10; ++i){
		r[i] = rand();
		printf("r[%d] = %d\n", i, r[i]);
	} 
	return r;
}

int main(){
	// 定义一个指向整数的指针
	int *p;
	int i;
	
	p = get_random();
	for (i=0; i<10; i++)
	{
		printf("*(p + [%d]) : %d\n", i, *(p + i) );
	} 
	return 0;
} 
```

输出：

```c
r[0] = 29700
r[1] = 2402
r[2] = 9987
r[3] = 3422
r[4] = 21316
r[5] = 12961
r[6] = 28050
r[7] = 11542
r[8] = 27441
r[9] = 4566
*(p + [0]) : 29700
*(p + [1]) : 2402
*(p + [2]) : 9987
*(p + [3]) : 3422
*(p + [4]) : 21316
*(p + [5]) : 12961
*(p + [6]) : 28050
*(p + [7]) : 11542
*(p + [8]) : 27441
*(p + [9]) : 4566
```

## 10.9 指针与函数的关系

### 1）函数指针

<font color=red>**一个函数在编译之后，会占据一部分内存，其函数名为该函数的首地址**</font>。可以把一个指针声明成为一个指向函数的指针。

<font color=dark>**C 语言规定函数名会被转换为指向这个函数的指针**，除非这个函数名作为 `&` 操作符或 `sizeof` 操作符的操作数（注：函数名用于 sizeof 的操作数是非法的）。也就是说 `f = test;` 中 test 被自动转换为 `&test`，而 `f = &test;` 中已经显式使用了 `&test`，所以 `test` 不会再发生转换。因此，**直接引用函数名等效于在函数名上应用 `&` 运算符**，**两种方法都会得到指向该函数的指针**。</font>

**指向函数的指针必须初始化，或者具有 0 值，才能在函数调用中使用**。

与数组一样：

- 1）禁止对指向函数的指针进行自增运算 `++`
- 2）禁止对函数名赋值，函数名也不能用于进行算术运算

实例1：

```c
#include <stdio.h>
#include <stdlib.h>

void test( ){
    printf(" func test called!\n");
}

int max_of_three(int x, int y, int z){
	int max;
	
	max = z;
	
	if (x > y){
		max = x;
	}
	else{
		if (y > z){
			max = y;
		}
	}
	return max;
} 

int main() {
    /* ---------------------------测试1-------------------------*/
    void (*f) ();
    f = test;
    
    f ();    // 函数调用方式 1
    (*f)();  // 函数调用方式 2
    
    printf("  test = %p\n",  test);
    printf(" &test = %p\n", &test);
    printf(" *test = %p\n", *test);
	
	printf("-------------------------------\n");
    /* ---------------------------测试2-------------------------*/
	// 定义一个函数指针
	int (*p)(int, int, int);
	int a, b, c, result;
	
	// 把函数max_of_three赋值给变量p, 使p指向函数
	p = max_of_three;
	
	// 非法操作： 
	// max_of_three ++;   // 禁止对指向函数的指针进行自增运算 
	// max_of_three += 1; // 不能对函数名赋值，函数名也不能进行算术运算 
	// p ++;
	// p += 1;
	
	printf("please enter three variable:");
	scanf("%d %d %d", &a, &b, &c);
	printf("you entered: a = %d, b = %d, c = %d\n", a, b, c);
	result = (*p)(a, b, c);
	printf("the maximum is: %d\n", result);
	
	system("pause");
	
	return 0;
}
```

函数名 `test` 是一个符号，用来标识一个函数的入口地址。**使用中，函数名会被转换为指向这个函数的指针，指针的值就是函数的入口地址**。`&test` 显式获取函数的地址。由于 `test` 已经被转换成了函数指针，指向这个函数，所以 `*test` 可以认为是取这个指针所指向的函数名；而根据函数名又会被转换为指向该函数的指针，这个函数也转变成了一个指针，所以 **`*test` 也是一个指向函数 `test` 的指针**。也就是说：**`*test --> *(&test) --> test --> &test`**。

实例2：

```c
#include <stdio.h>


int func(int x, int y){
    return x + y;
} 

int main(){
	int (*pfunc) (int, int);
	
	pfunc = func;
	// pfunc = &func;
	// &func 与 func 的值和类型都一样，二者均可 
	
	/* 以下几种调用方式的结果均相同*/ 
	// 通过 函数指针 调用函数 
	int a = (*pfunc) (5, 7);	
	int b = pfunc(5, 7);
	int c = (&func) (5, 7);
	int d = (*func) (5, 7);
	int e = func(5, 7);
	
	printf("results of different ways: %d, %d, %d, %d, %d", a, b, c, d, e);
	
	return 0;
}
```

输出：

```c
results of different ways: 12, 12, 12, 12, 12
```

---

### 2）指针函数 (返回值为指针的函数)

所谓指针函数，就是返回指针的函数。

C 语言的库函数中有很多都是指针函数，比如字符串处理函数，下面给出一些函数原型：

```c
char *strcat( char *dest, const char *src );
char *strcpy( char *dest, const char *src );
char *strchr( const char *s, int c );
char *strstr( const char *src, const char *sub );
```

## 10.10 指针详解

### 1）复杂指针说明

有关指针的运算原则：**从变量名处起，根据运算符优先级结合，一步步分析**。

-  **`int p;`** -- 普通的整型变量。
-  **`int *p;`** -- 从 p 开始，先与 `*` 结合，说明 p 是一个指针；然后与 int 结合，说明指针所指向的内容的类型为 int 型。所以 **p 是一个返回整型数据的指针**。
-  **`int p[3];`** -- 从 p 开始，先与 `[]` 结合，说明 p 是一个数组，然后与 int 结合，说明数组中的元素类型是整型，所以 **p 是一个由整型数据组成的数组**。
-  **`int *p[3];`** -- 从 p 开始，先与 `[]` 结合，因为其优先级比 `*` 高，所以 p 是一个数组；然后再与 `*` 结合，说明数组里的元素是指针类型，然后再与 int 结合，说明指针所指向的内容的类型是整型的，所以 **p 是一个由返回整型数据的指针所组成的数组**。
-  **`int (*p)[3];`** -- 从 p 开始，先与 `*` 结合，说明 p 是一个指针；然后与 `[]` 结合 (与 `()` 结合只是为了改变优先级，可以忽略)，说明指针所指向的内容是一个数组，然后再与 int 结合，说明数组中的元素类型是整型。**所以 p 是一个指向由整型数据组成的数组的指针**。
-  **`int **p;`** -- 从 p 开始，先与 `*` 结合，说明 p 是一个指针；然后再与 `*` 结合，说明**指针所指向的元素是指针**；然后再与 int 结合，说明该指针所指向的元素是整型数据。
-  **`int p(int);`** -- 从 p 开始，先与 `()` 结合，说明 p 是一个函数；然后进入 `()` 里分析，说明该函数有一个整型变量的参数，然后再与外面的 int 结合，说明函数的返回值是一个整型数据。
-  **`int (*p)(int);`** -- 从 p 处开始，先与 `*` 结合，说明 p 是一个指针；然后与()结合，说明指针指向的是一个函数，然后再与()里的 int 结合，说明函数有一个int 型的参数，再与最外层的 int 结合，说明函数的返回类型是整型，所以 **p 是一个指向有一个整型参数且返回类型为整型的函数的指针**。
-  **`int *(*p(int))[3];`** -- 从 p 开始，先与 `()` 结合，说明 p 是一个函数；然后进入 () 里面，与 int 结合，说明函数有一个整型变量参数；然后再与外面的 `*` 结合，说明函数返回的是一个指针；然后到最外面一层，先与 `[]` 结合，说明返回的指针指向的是一个数组；然后再与 `*` 结合，说明数组里的元素是指针；然后再与 int 结合，说明指针指向的内容是整型数据。所以 **p 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。**

---

### 2）细说指针

**指针是一个特殊的变量，其存储的数值被解释成为内存中的一个地址**。要搞清一个指针需要搞清四方面的内容：

- 指针的类型
- 指针所指向的类型
- 指针的值或者指针所指向的内存区
- 指针本身所占据的内存区

实例1，先声明几个指针：

```c
int  *ptr;
char *ptr;
int **ptr;
int *ptr[2];    // 由指针组成的数组
int (*ptr)[3];  // 指向数组的指针
int *(*ptr)[4]; // 
```

#### [1] 指针的类型

从语法角度看，**将指针声明语句中的指针变量名去掉，剩下的部分就是指针的类型**。也就是指针本身所具有的类型。上例中：

- **`int *ptr;`** : 指针的类型是 **`int *`**
- **`char *ptr;`** : 指针的类型是 **`char *`**
- **`int **ptr;`** : 指针的类型是 **`int **`**
- **`int (*ptr)[3];`** : 指针的类型是 **`int(*)[3]`**
- **`int *(*ptr)[4];`** : 指针的类型是 **`int *(*)[4]`**

#### [2] 指针指向的类型

**当通过指针访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待**。从语法上看，**只须把指针声明语句中的指针变量名和其指针声明符*去掉，剩下的就是指针所指向的类型**。上例中：

- **`int *ptr;`** : 指针所指向的类型是 **`int`**
- **`char *ptr;`** : 指针所指向的的类型是 **`char`**
- **`int **ptr;`** : 指针所指向的的类型是 **`int`***
- **`int( *ptr)[3];`** : 指针所指向的的类型是 **`int()[3]`**
- **`int *(*ptr)[4];`** : 指针所指向的的类型是 **`int *()[4]`**

在指针的算术运算中，指针所指向的类型有很大的作用。指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。


#### [3] 指针的值 (指针所指向的内存或地址) 

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32位程序里内存地址全都是32 位长。

**指针所指向的内存区**就是**从指针的值所代表的那个内存地址开始，长度为 `si zeof(指针所指向的类型)` 的一片内存区**。

**一个指针的值是XX，表示该指针指向了以 XX 为首地址的一片内存区域；一个指针指向了某块内存区域，表示该指针的值是这块内存区域的首地址**。

指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在实例1中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

#### [4] 指针本身所占据的内存区

函数 `sizeof(指针的类型)` 可以得到指针本身所占用的内存。在 32 位平台里，指针本身占据了 4 个字节的长度。

指针本身占据的内存这个概念在**判断一个指针表达式是否是左值**时很有用。

---

### 3）指针的算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。

```c
char a[20];
int *ptr = (int *)a;// 强制类型转换并不会改变 a 的类型
ptr ++;
```

上例中，指针 ptr 的类型是 `int*`，它指向的类型是 int，它被初始化为指向整型变量 a。<font color=red>`ptr ++;` 在编译器中是这样处理的：**它把指针 ptr 的值加上了 `sizeof(int)`，在 32 位程序中，是被加上了 4，因为在 32 位程序中，`int` 占 4 个字节**。</font>

<font color=blue>一个指针 `*ptrold` 加/减一个整数 `n` 后，结果是一个新的指针 `*ptrnew`，二者类型相同，所指向的类型也相同。`*ptrnew` 的值将比 `*ptrold` 的值增加/减少了 `n × sizeof(ptrold 所指向的类型)` 个字节。即 `*ptrnew` 所指向的内存区将比 `*ptrold` 所指向的内存区向高/低地址方向移动了 `n × sizeof(ptrold 所指向的类型)`  个字节。</font>

**两个指针不能进行加法运算**，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。**两个指针可以进行减法操作**，但必须类型相同，一般用在数组方面。

---

### 4）运算符 `&` 和 `*`

**`&`** 是取地址运算符，**`*`** 是间接运算符。

**`&a`** 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址是 a 的地址。

**`*p`** 的运算结果是 p 所指向的东西：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。

```c
int a=12; 
int b; 
int *p; 
int **ptr;

p = &a; /* &a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是 a的地址。*/

*p = 24; /* *p的类型是int，占用的地址是 p所指向的地址，显然，*p就是变量a。*/

ptr = &p; /* &p 的结果是个指针，类型是int **。该指针所指向的类型是 p的类型，这里是int*。该指针所指向的地址就是指针 p 的地址。*/

*ptr = &b; /* *ptr 是个指针，&b 的结果也是个指针，且这两个指针的类型和所指向的类型相同，所以用&b 来给*ptr 赋值。*/

**ptr = 34; /* *ptr 的结果是 ptr 所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果是一个int 类型的变量。*/
```

---

### 5）指针表达式

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

```c
int a,b;
int array[10];
int *pa;

pa=&a; // &a 是一个指针表达式。
Int **ptr=&pa; // &pa 也是一个指针表达式。
*ptr=&b; // *ptr 和&b 都是指针表达式。
pa=array;
pa++; // 这也是指针表达式。

char *arr[20];
char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式
char *str;

str=*parr; //*parr 是指针表达式
str=*(parr+1); //*(parr+1)是指针表达式
str=*(parr+2); //*(parr+2)是指针表达式
```

### 6）数组合指针的关系

```c
int array[10]={0,1,2,3,4,5,6,7,8,9}, value;

value=array[0]; //也可写成：value=*array;
value=array[3]; //也可写成：value=*(array+3);
value=array[4]; //也可写成：value=*(array+4);
```

一般而言数组名 array 代表数组本身，类型是 int[10]，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型为 int* 所指向的类型，其是数组单元的类型，即 int。因此 *array 等于 0 就不奇怪了。同理，array+3 是一个指向数组第 3 个单元的指针，所以 ***(array+3)** 等于 3。其它依此类推。

```c
char *str[3]={
    "Hello,thisisasample!",
    "Hi,goodmorning.",
    "Helloworld"
};
char s[80]；
strcpy(s,str[0]); //也可写成strcpy(s,*str);
strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));
strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));
```

上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char **，它指向的类型是 char *。

*str 也是一个指针，它的类型是 char *，它所指向的类型是 char，它指向的地址是字符串 "Hello,thisisasample!" 的第一个字符的地址，即 'H' 的地址。注意:字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变,且只能是右值.如果看成指针的话, 他即是常量指针, 也是指针常量。

str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char**，它指向的类型是 char*。

*(str+1) 也是一个指针，它的类型是 char*，它所指向的类型是 char，它指向 "Hi,goodmorning." 的第一个字符 'H'。

**下面总结一下数组的数组名(数组中储存的也是数组)的问题:**

声明了一个数组 **TYPE array[n]**，则数组名称 array 就有了两重含义：

- 第一，它代表整个数组，它的类型是 **TYPE[n]**；
- 第二，它是一个常量指针，该指针的类型是 **TYPE\***，该指针指向的类型是 **TYPE**，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时 sizeof 函数测出的是整个数组的大小。

在表达式 *array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。**sizeof(\*array)** 测出的是数组单元的大小。

表达式 array+n（其中n=0，1，2，.....）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是 **TYPE \***，它指向的类型是 TYPE，它指向数组第 n 号单元。故sizeof(array+n)测出的是指针类型的大小。在 32 位程序中结果是 4。

实例：

```c
int array[10];
int (*ptr)[10];
ptr = &array;：
```

**上例中 ptr 是一个指针，它的类型是 int(\*)[10]，他指向的类型是 int[10] ，用整个数组的首地址来初始化它**。在语句 ptr=&array中，array 代表数组本身。

则在 32 位程序中，有：

```c
sizeof(int(*)[10])==4
sizeof(int[10])==40
sizeof(ptr)==4
```

<font color=red>**实际上，`sizeof(对象)` 测出的都是对象自身的类型的大小**。</font>

---

### 7）指针和结构类型的关系

可以声明一个指向结构类型对象的指针。

```c
struct MyStruct
{
    int a;
    int b;
    int c;
};
// 声明了结构对象ss，并把 ss 的成员初始化为20，30 和40。
struct MyStruct ss = {20,30,40};

// 声明了一个指向结构对象ss的指针。它的类型是 MyStruct *,它指向的类型是MyStruct。
struct MyStruct *ptr = &ss;

// 声明了一个指向结构对象ss的指针。但是pstr和它被指向的类型ptr是不同的。
int *pstr = (int*)&ss;
```

请问怎样通过指针 ptr 来访问 ss 的三个成员变量？

答案：

```c
ptr->a; //指向运算符，或者可以这们(*ptr).a,建议使用前者
ptr->b;
ptr->c;
```

又请问怎样通过指针 pstr 来访问 ss 的三个成员变量？

答案：

```c
*pstr； //访问了ss 的成员a。
*(pstr+1); //访问了ss 的成员b。
*(pstr+2) //访问了ss 的成员c。
```

---

### 8）指针和函数的关系

可以把一个指针声明成为一个指向函数的指针。

```c
int fun1(char *,int);

int (*pfun1)(char *,int);

pfun1 = fun1;
int a = (*pfun1)("abcdefg",7); //通过函数指针调用函数。
```

---

### 9）指针类型转换

当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。

```c
float f = 12.3;
float *fptr = &f;
int *p;
```

假如想让指针 p 指向实数 f，应该怎么办？下面的语句对吗？

```c
p = &f;
```

不对。因为指针 p 的类型是 int *，它指向的类型是 int。表达式 &f 的结果是一个指针，指针的类型是 float *，它指向的类型是 float。

两者不一致，直接赋值的方法是不行的。对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致。为了实现目的，需要进行强制类型转换：

```c
p = (int*)&f;
```

如果有一个指针 p，我们需要把它的类型和所指向的类型改为 **`TYEP *TYPE`**， 那么语法格式是：**`(TYPE *)p`**。这样强制类型转换的结果是一个新指针，该新指针的类型是 **`TYPE *`**，它指向的类型是 **`TYPE`**，它指向的地址就是原指针指向的地址。而原来的指针p 的一切属性都没有被修改。

**一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换**：

```c
void fun(char*);
int a=125,b;

// 强制类型转换
fun((char*)&a);

void fun(char*s)
{
    char c;
    c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;
    c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;
}
```

**这是一个 32 位程序，故 int 类型占了四个字节，char 类型占一个字节**。函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒。在函数调用语句中，实参 &a 的结果是一个指针，它的类型是 int *，它指向的类型是 int。形参的指针类型是 char *，它指向的类型是 char。所以在实参和形参的结合过程中，必须进行一次从 int * 类型到 char * 类型的转换。

想象编译器进行转换的过程：编译器先构造一个临时指针 char *temp，然后执行 temp=(char *)&a，最后再把 temp 的值传递给 s。所以最后的结果是：s 的类型是 char *，它指向的类型是 char，它指向的地址就是 a 的首地址。

**指针的值就是指针指向的地址，在 32 位程序中，指针的值其实是一个 32 位整数**。

那可不可以把一个整数当作指针的值直接赋给指针呢？像下面的语句：

```c
unsigned int a;
TYPE *ptr; // TYPE 是int，char 或结构类型等等类型
a = 20345686;

ptr = 20345686; // 我们的目的是要使指针ptr指向地址20345686
ptr = a; // 我们的目的是要使指针ptr指向地址20345686
// 编译一下发现后面两条语句全是错的

unsigned int a;

// TYPE 是int，char 或结构类型等等类型。
TYPE *ptr; 

a = N; //N 必须代表一个合法的地址；
ptr = (TYPE*)a; // 将无符号整数 a 视为地址
```

严格说来这里的 `(TYPE *)` 和指针类型转换中的 `(TYPE *)` 还不一样。这里的 `(TYPE*)` 的意思是把无符号整数 a 的值当作一个地址来看待。能不能反过来，把指针指向的地址即指针的值当作一个整数取出来？完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：

```c
int a=123, b;
int *ptr = &a;
char *str;

b = (int)ptr; //把指针ptr的值当作一个整数取出来。
str = (char*)b; //把这个整数的值当作一个地址赋给指针str。
```

<font color=red>**可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针**。</font>

---

### 10）指针的安全问题

看下面的例子：

```c
char s='a';
int *ptr;

ptr = (int *)&s;

*ptr = 1298;
```

指针 ptr 是一个 int * 类型的指针，它指向的类型是 int。它指向的地址是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这会造成崩溃性的错误。

再来看一例：

```c
char a;
int *ptr=&a;

ptr++;
*ptr=115;
```

第 3 句对指针 ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。

第 4 句往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：<font color=blue>**指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的上下界**，否则也会造成类似的错误</font>。

在指针的强制类型转换：**`ptr1=(TYPE *)ptr2`** ，如果 `sizeof(ptr2的类型)` 大于  `sizeof(ptr1 的类型)`，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果 `sizeof(ptr2 的类型)` 小于`sizeof(ptr1 的类型)`，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。