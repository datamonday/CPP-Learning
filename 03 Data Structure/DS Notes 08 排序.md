# 8. 排序

## 8.1 排序概述

什么是排序？

将一组杂乱无章的数据按一定规律顺次排列起来。即，将无序序列排成一个有序序列（由小到大或由大到小）的运算。如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域。

![](imgs\s1.png)

![](imgs\s2.png)

![](imgs\s3.png)

![](imgs\s4.png)

![](imgs\s5.png)

![](imgs\s6.png)

## 8.2 插入排序

![](imgs\s7.png)

![](imgs\s8.png)

![](imgs\s9.png)

![](imgs\s10.png)

### 8.2.1 直接插入排序

![](imgs\s11.png)

![](imgs\s12.png)

![](imgs\s13.png)

![](imgs\s14.png)

![](imgs\s15.png)

![](imgs\s16.png)

### 8.2.2 折半插入排序

![](imgs\s17.png)

![](imgs\s18.png)

![](imgs\s19.png)

![](imgs\s20.png)

### 8.2.3 希尔排序

基本思想：先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行一次直接插入排序。

希尔排序算法的特点：

- 缩小增量
- 多变插入排序

![](imgs\s21.png)

```C
void shell_insert(SqList &L, int dk){
    // 对顺序表L进行一趟增量为dk的shell排序，dk维步长因子
    for(i = dk + 1; i < L.length; ++i){
        if(r[i].key < r.[i-dk].key)P
            r[0] = r[i];
        for(j = i - dk; j > 0 && (r[0].key < r[j].key); j = j - dk){
            r[j + dk] = r[j];
        }
        r[j + dk] = r[0];
    }
}
```

![](imgs\s22.png)

![](imgs\s23.png)

## 8.3 交换排序

### 8.3.1 冒泡排序

![](imgs\s24.png)

![](imgs\s25.png)

![](imgs\s26.png)

![](imgs\s27.png)

冒泡排序优点：每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素。

如何提高效率？一旦某一趟比较时不出现记录交换，就说明已经排好序了，就可以约束本算法。

```C
void bubble_sort(int arr[], int n){
    int i, j, temp;
    // 比较 n-1 轮
    for(i = 0; i < n - 1; i++)
        // 第 i 轮比较 n-i 次
        for(j = 0; j < len - 1 - i; j++)
            if (arr[j] > arr[j+1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
}
int main() {
    int arr[] = {22, 34, 3, 32, 82, 55, 89, 50, 37, 5};
    int len = (int) sizeof(arr) / sizeof(*arr);
    bubble_sort(arr, len);
    int i;
    for (i = 0; i < len; i++)
        printf("%d ", arr[i]);
    return 0;
}
```



![](imgs\s28.png)

![](imgs\s29.png)

### 8.3.2 快速排序

![](imgs\s30.png)

![](imgs\s31.png)

快速排序基本思想：通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序。

具体实现：选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边。

（枢轴）中间数：可以是第一个数、最后一个数、最中间一个数、任选一个数等。

![](imgs\s32.png)

![](imgs\s33.png)

![](imgs\s34.png)

![](imgs\s35.png)

![](imgs\s36.png)

![](imgs\s37.png)

![](imgs\s38.png)

## 8.4 选择排序

### 8.4.1 简单选择排序

基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置。

基本操作：

- 首先通过 n-1 次关键字比较，从 n 个记录中找出关键字最小的记录，将它与第一个记录交换；
- 在通过 n-2 次比较，从剩余的 n-1 个记录中找出关键字次小的记录，将它与第二个记录交换；
- 重复上述操作，共进行 n-1 趟排序后，排序结束。 

![](imgs\s39.png)

![](imgs\s40.png)

![](imgs\s41.png)

### 8.4.2 堆排序

![](imgs\s42.png)

![](imgs\s43.png)

![](imgs\s44.png)

实现堆排序需要解决两个问题：

- 如何由一个无序序列建成一个堆？
- 如何在输出堆顶元素后，调整剩余元素为一个新的堆？

![](imgs\s45.png)

![](imgs\s46.png)

从堆的调整可以看出：

- 对于一个无序序列反复筛选就可以得到一个堆；即：从一个无序序列建堆的过程就是一个反复“筛选”的过程。

如何由一个无序序列建成一个堆？

- 显然，单节点的二叉树是堆，**在完全二叉树中所有以叶子结点（序号 i>n/2）为根的子树是堆**。
- 这样，我们只需要依次将以序号为 n/2，n/2-1，...，1 的结点为根的子树均调整为堆即可。
- 即：对应由 n 个元素组成的无序序列，筛选只需要从第 n/2 个元素开始。

堆实质上是一个线性表，可以顺序存储一个堆。

![](imgs\s47.png)

由以上分析可知：若对一个无序序列建堆，然后输出根，重复该过程就可以由一个无序序列输出有序序列。实质上，堆排序就是利用完全二叉树中父节点与孩子结点之间的内在关系来排序的。

![](imgs\s48.png)

![](imgs\s49.png)

堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复筛选上。堆排序在最坏情况下，其时间复杂度也为O(nlong2n)，这是堆排序的最大优点。无论待排序列中的记录是正序还是逆序排列，都不会使堆排序处于最好或最坏的状态。

- 堆排序仅需一个记录大小供交换使用的辅助存储空间。
- **堆排序是一种不稳定的排序方法，它不适用于待排序记录个数n较少的情况下，但对于n较大的文件还是很有效的**。

## 8.5 归并排序

![](imgs\s50.png)

![](imgs\s51.png)

整个归并排序仅需 向上取整【log2n】趟。

如何将两个有序序列合并成一个有序序列？

![](imgs\s53.png)

归并排序：

![](imgs\s52.png)

## 8.6 基数排序

![](imgs\s54.png)

![](imgs\s55.png)

![](imgs\s56.png)

![](imgs\s57.png)

对关键字取值范围确定的序列比较好用。

## 8.7 各种排序方法比较

![](imgs\s58.png)

![](imgs\s59.png)

![](imgs\s60.png)

![](imgs\s61.png)

![](imgs\s62.png)

## 8.7 外部排序

需自行补充

另：第七章查找，B树，红黑树也需要自行补充。



