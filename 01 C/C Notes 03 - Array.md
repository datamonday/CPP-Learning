---
> Contributor: datamonday
>
> Repo: https://github.com/datamonday/CPP-TechStack

---
# 9. 数组

> update：2021-5-12

**位序比数组索引多1**。

**数组（Array）**就是**一系列具有相同类型的数据的集合**，这些数据在内存中依次挨着存放，彼此之间没有缝隙。即**所有的数组元素都是由连续的内存位置组成**。最低的地址对应第一个元素，最高的地址对应最后一个元素。数组中的特定元素可以通过索引访问，第一个索引值为 0。下图是一个长度为 **10** 的数组：

![img](./imgs/carray.png)

C语言数组属于**构造数据类型**。一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。按数组元素的类型，数组又可分为数值数组、字符数组、指针数组、结构数组等。

## 9.1 数组声明

C 中声明数组，需要指定元素的类型和元素的数量：

```c
type arrayName [ arraySize ];
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C 数据类型。例如，声明一个类型为 double 的包含 10 个元素的数组 **balance**：

```c
double balance[10];
```

现在，balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

## 9.2 数组初始化

```c
// 1.完全初始化
int a[5] = {1, 2, 3, 4, 5};

// 2.不完全初始化，未被初始化的元素自动为零
int a[5] = {1, 2, 3};

// 3.不初始化，所有元素是垃圾值
int a[5];

// 4.清零
int a[5] = {0};
```

```c
// 5.[错误写法]
int a[5];
a[5] = {1, 2, 3, 4, 5}; // 此处的a[5]表示数组的第6个元素

// 6.[错误写法]
int a[5] = {1, 2, 3, 4, 5};
int b[5];
// 若想将a数组中的值全部复制给b数组
// 错误写法！因为变量a和b分别存储的是数组a和b的首地址
b = a; 
// 正确写法
for (i=0; i<5; ++i){
    b[i] = a[i];
}
```

注意：

- <font color=red>**只有在定义数组的同时才可以整体赋值，其它情况下整体赋值都是错误的**</font>。例如上例5是错误的。
- **数组之间的赋值操作，需要用for循环，逐个赋值**！而不能像例6一样！

C 语言中，数组可以逐个元素初始化，也可以使用一个初始化语句：

```c
double balance[5] = {1.0, 200.0, 333.0, 700.0, 1000.0}
```

大括号 { } 中元素的数目 <= 方括号 [ ] 中指定的元素数目。**如果省略数组的大小，数组的大小则为初始化时元素的个数**。

为数组中某个元素赋值：

```c
// 把数组中第五个元素的值赋为 50.0
balance[4] = 50.0;
```

## 9.3 访问数组元素

数组元素可以通过数组名称加索引访问：

```c
// 把数组中第 10 个元素的值赋给 salary 变量
double salary = balance[9];
```

下面的实例使用声明数组、数组赋值、访问数组：

```c
# include "stdio.h"

int main() {
    // 1. n是一个包含10个整数的数组
	int a[5]; 
	int i, j;
	
	// 2. 初始化数组元素 
	for (i = 1; i <= 5; i++) {
		n[i] = i + 100; 
	} 
	
	// 3. 输出数组中的元素
	for (j = 0; j < 10; j++) {
		printf("a[%d] = %d\n", j, n[j]);
	} 
	return 0;
} 
```

```c
a[0] = 101
a[1] = 102
a[2] = 103
a[3] = 104
a[4] = 105
```

## 9.4 多维数组

**一个二维数组，本质上是一个一维数组的列表**。声明一个 x 行 y 列的二维整型数组：

```c
type arrayName [ x ][ y ];
```

其中，**type** 可以是任意有效的 C 数据类型，**arrayName** 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：

```c
int x[3][4];
```

![C 中的二维数组](./imgs/two_dimensional_arrays.jpg)

```c
// 三维整型数组
int threedim[5][10][4];
```

### 1）初始化二维数组

多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。

```c
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

**内部嵌套的括号是可选的，下面的初始化与上面是等同的**：

```c
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

### 2）访问二维数组元素

二维数组中的元素通过下标访问：

```c
// 获取数组第 3行第 4列的元素
int val = a[2][3];
```

使用嵌套循环处理二维数组：

```c
# include "stdio.h"

int main() {
	int a[3][2] = { {1,2}, {4,5}, {7,8}	};
	int i, j;
	
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 2; j++) {
			printf("a[%d][%d] = %d\n", i, j, a[i][j]);
		}
	}
    for (i = 0; i < 3; i++) {
		for (j = 0; j < 2; j++) {
            // 另一种格式化输出方式
            // - 表示左对齐
            printf("%-5d  ", a[i][j]);
		}
        printf("\n");
	}
	return 0; 
} 
```

输出：

```c
a[0][0] = 1
a[0][1] = 2
a[1][0] = 4
a[1][1] = 5
a[2][0] = 7
a[2][1] = 8
1      2
4      5
7      8
```

## 9.5 传递数组给函数

将数组作为参数传递给函数，有三种方式用来声明函数形参，这三种声明的方式结果是一样的，因为每种方式都会告诉编译器要接收一个整形指针。

**方式1：形参是一个指针**。

```c
void myfunc(int *param){
    
}
```

**方式2：形参是一个已经定义大小的数组**。

```c
void myfunc(int param[10]){
    
}
```

**方式3：形参是一个未定义大小的数组**。

```c
void myfunc(int param[]){
    
}
```

实例：

```c
# include <stdio.h>
double get_average(int arr[], int size);

int main() {
	int balance[5] = {500, 100, 100, 150, 150};
	double avg;
	
	avg = get_average(balance, 5);
	printf("平均值为：%.4f", avg);
	
	return 0;
} 

double get_average(int arr[], int size) {
	int i;
	double avg;
	double sum = 0;
	
	for (i=0; i < size; ++i) {
		sum += arr[i];
	}
	avg = sum / size;
	return avg;
}
```

## 9.6 从函数返回数组

**C 语言不允许返回一个完整的数组作为函数的参数，但是可以指定不带索引的函数名来返回一个指向数组的指针**。

如果想要从函数返回一个一维数组，必须声明一个返回指针的函数：

```c
int *myfunc(){

}
```

**C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量**。

下面的函数，它会生成 10 个随机数，并使用数组来返回它们：

```c
# include "stdio.h"
# include "stdlib.h"
# include "time.h"

int *get_random(){
	static int r[10];
	int i;
	
	// 设置随机种子 
	srand( (unsigned) time (NULL) );
	for (i = 0; i < 10; ++i){
		r[i] = rand();
		printf("r[%d] = %d \n", i, r[i]);
	}
	
	return r;
}

int main(){
	
	// 一个指向整数的指针
	int *p;
	int i;
	
	p = get_random();
	
	for (i = 0; i < 10; i++){
		printf("*(p + %d) : %d\n", i, *(p + i));
	} 
	return 0;
}
```

`srand((unsigned)time(NULL))` 是初始化随机函数种子：

-  其将当前系统时间作为种子，由于时间是变化的，种子变化，可以产生不相同的随机数。计算机中的随机数实际上都不是真正的随机数，如果两次给的种子一样，是会生成同样的随机序列。所以，一般都会以当前的时间作为种子来生成随机数，这样更加的随机。
-  使用时，参数可以是unsigned型的任意数据，比如 `srand(10)`。

## 9.7 指向数组的指针

**数组名是一个指向数组中第一个元素的常量指针**：

```c
double balance[10];
```

**balance** 是一个指向 `&balance[0]` 的指针，即数组 balance 的第一个元素的地址。因此，**下面的程序片段把 p 赋值为 balance 的第一个元素的地址**：

```c
double *p;
double balance[10];

p = balance;
```

<font color=blue>**使用数组名作为常量指针是合法的，反之亦然**。因此，**`*(balance + 4)` 是一种访问 balance[4] 数据的合法方式**。</font>

一旦把第一个元素的地址存储在 p 中，就可以使用 `*p、*(p+1)、*(p+2)` 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：

```c
#include <stdio.h>
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
   double *p;
   int i;
 
   p = balance;
 
   /* 输出数组中每个元素的值 */
   printf( "使用指针的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(p + %d) : %f\n",  i, *(p + i) );
   }
 
   printf( "使用 balance 作为地址的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(balance + %d) : %f\n",  i, *(balance + i) );
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
使用指针的数组值
*(p + 0) : 1000.000000
*(p + 1) : 2.000000
*(p + 2) : 3.400000
*(p + 3) : 17.000000
*(p + 4) : 50.000000
使用 balance 作为地址的数组值
*(balance + 0) : 1000.000000
*(balance + 1) : 2.000000
*(balance + 2) : 3.400000
*(balance + 3) : 17.000000
*(balance + 4) : 50.000000
```

---

## 9.8 数组相关算法（待补充）

### 1）逆置

```c
# include <stdio.h>

int main(){
	int a[7] = {1, 2, 3, 4, 5, 6, 7};
	int i=0; 
	int j=6;
	int t;
	
	while(i < j){
		t = a[i];
		a[i] = a[j];
		a[j] = t;
		
		i++;
		j--;
	}
	
	int k;
	printf("After Reverse array: \n");
	for (k=0; k<7; ++k){
		printf("%d ", a[k]);
	}
	
	return 0;
} 
```

```c
After Reverse array:
7 6 5 4 3 2 1
```

核心思想是：第一个元素与最后一个元素互换，第二个元素与倒数第二个元素互换，以此类推。

---

### 2）排序



---

### 3）最值



---

### 4）查找



---

### 5）插入





---

### 6）删除





---